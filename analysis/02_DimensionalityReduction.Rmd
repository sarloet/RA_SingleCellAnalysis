---
title: "Dimensionality Reduction"
subtitle: "02_DimensionalityReduction"
author: "SarahL."
date: "`r format(Sys.time(), '%b %e %Y %H:%M:%S')`"
output: 
  html_document:
    toc: true
    number_sections: true   
    toc_float: true
    code_folding: hide
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(cache = FALSE, cache.lazy = FALSE)
knitr::opts_chunk$set(dpi = 300, fig.align = "center")
knitr::opts_chunk$set(out.width = "100%", out.height = "100%")
```


# Feature Selection and Dimensionality Reduction

## Setup

### Standard packages

```{r LoadPackages, warning=FALSE}
library(here)
source(here("code", "standard_libraries.R"))
```

### Additional Packages

```{r LoadAddPackages, warning=FALSE}
#Load Packages

suppressPackageStartupMessages({
library(intrinsicDimension)
})

```

### Set Parameter

```{r Setup}
set.seed(123)
bpp <- BiocParallel::MulticoreParam(parallel::detectCores()-1, RNGseed=123)
path <- here::here()
```


## Load Data

```{r LoadDataset}
# RA DATASET
sce <- readRDS(file = paste0(path,'/output/01_sce_QualityControl.rds'))

```


### Explore Dataset

```{r ShowDim}
#Dimensions of count matrix
dim(sce)
```


## Feature selection

In feature selection the goal is to remove genes which are uninteresting or uninformative to both improve computation and by reducing this ‘noise’ hopefully enable us to more clearly see the true biology in our data. We make the assumption that most of the low level variance is not caused by real biology and is due to stochastic sampling in the single cell protocol and various other technical effects. The genes which have the most variance are therefore the ones that reflect the real biological difference and are what we want to focus on. 

### Quantifying per-gene variation

```{r ModelGeneVar}
# HVG selection with Turned off weighting to avoid overfitting for each donor.
dec <- modelGeneVar(sce, block=sce$Sample, density.weights=FALSE)

```

```{r TopHVGTable}
#Top HVG table
as.data.frame(dec[order(dec$bio, decreasing=TRUE),]) %>%
  dplyr::select(c("mean", "total", "tech", "bio", "p.value", "FDR")) %>%
  head(n=10)

```

### Select Highly Variable Genes

In this analysis we take the top 3000 genes with largest (biological) variation.
```{r GetTopHVGs}
## Extract top genes using scater package

# Get the top 10% of genes.
#top.hvgs <- getTopHVGs(dec, prop=0.1)

# Get the top 3000 genes.
top.hvgs <- getTopHVGs(dec, n=3000)

# Get all genes with positive biological components.
#top.hvgs <- getTopHVGs(dec, var.threshold=0)

# Get all genes with FDR below 5%.
#top.hvgs <- getTopHVGs(dec, fdr.threshold=0.05)

length(top.hvgs)#Check HVG amount

```


### Plot per-gene variation

Plot variance vs mean for each gene and visualise the limit of technical variance according to the fitted trend line. We would regard those features below the trend line as technical noise.
```{r VariationPlot}
# Mark HVGs in sce
rowData(sce)$hvg <- rownames(sce) %in% top.hvgs

# Plot per-gene variation
per.block <- dec$per.block
par(mfrow=c(2, 2))
for (i in seq_along(per.block)) {
    decX <- per.block[[i]]
    plot(decX$mean, decX$total, col= c("#F5953C","#7A95BD")[(names(metadata(decX)$mean) %in% top.hvgs)+1], xlab="Mean log-expression", 
        ylab="Variance", main=names(per.block)[i] )
    curve(metadata(decX)$trend(x), col="black", add=TRUE)
    legend("topright", legend=c("Not HVG", "HVG"), col = c("#F5953C","#7A95BD"),bty="n",pch=10)
}
```


## Dimensionality Reduction

Dimensionality reduction aims to reduce the number of separate dimensions in the data. This is possible because different genes are correlated if they are affected by the same biological process. Thus, we do not need to store separate information for individual genes, but can instead compress multiple features into a single dimension. This reduces computational work in downstream analyses like clustering, as calculations only need to be performed for a few dimensions, rather than thousands.

### Perform Principal Components Analysis

PCA is a linear transformation of the data, such that a set of variables (genes) are turned into new variables called Principal Components (PCs). PCs combine information across several genes in a way that best captures the variability observed across samples (cells).

```{r RunPCA}
#Run PCA
sce <- runPCA(sce, subset_row = top.hvgs)

```

#### Chosing the number of PCs

The advantage of using PCA is that the total amount of variance explained by the first few PCs is usually enough to capture most of the signal in the data. Therefore, we can exclude the remaining PCs without much loss of information. 

```{r ShowPC}
#Visualise PCA
data.frame(reducedDim(sce, "PCA")[1:10, 1:5])

# extract variance explained
pca_pct_variance <- data.frame(variance = attr(reducedDim(sce, "PCA"), "percentVar"))
pca_pct_variance$PC <- 1:nrow(pca_pct_variance)

#PCA dim estimate the maxLikGlobalDimEst
elbow <- ceiling(as.numeric(maxLikGlobalDimEst(as.matrix(reducedDim(sce, "PCA")), k=5)))
cat(paste0("Elbow Point: ",elbow))
#cat(paste0("Elbow Point: ",findElbowPoint(pca_pct_variance$variance)))
```

```{r PCvsVariance}
# Elbow Plot (PC vs variance)
ggplot(pca_pct_variance,aes(PC, variance)) +geom_line(color="grey") +geom_point() +labs(y = "Variance explained (%)")+ geom_vline(xintercept = elbow,color="red")+theme_classic()+ ggtitle("Percentage variance explained by PCs")

```

```{r SelectPC}
#PCA select nr of PC
reducedDim(sce,"PCA_reduced") <- reducedDim(sce,"PCA")[,seq_len(elbow)]

cat("Reduced Dimensions in sce :",reducedDimNames(sce),"\n")
cat("Nr PCs in PCA :", ncol(reducedDim(sce,"PCA")),"\n")
cat("Nr PCs in PCA_reduced :", ncol(reducedDim(sce,"PCA_reduced")),"\n")


```

#### Plot PCA  {.tabset}

##### PCA 

```{r PlotPCA2}
#Plot PCA 
plotReducedDim(sce, dimred = "PCA_reduced", colour_by = "Sample",point_alpha=0.8,point_size=0.1)+ 
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" ) +
  labs( x='PCA 1', y='PCA 2' )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))

```

##### PCA three PC's

```{r PlotPCA3}
#Plot PCA 
plotReducedDim(sce, dimred = "PCA_reduced", ncomponents = 3, colour_by = "Sample",point_alpha=0.8,point_size=0.1)+ 
  theme(strip.background=element_rect(fill="white"))+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))

```


#### Plot PCA Facet {.tabset}

##### PCA per Sample

```{r PlotFacetPCA1,fig.height=10, fig.width=15}
#Plot PCA per sample
plotReducedDim(sce, dimred="PCA_reduced", colour_by="Sample",point_alpha=0.8,point_size=0.5) + 
  facet_wrap(~sce$Sample)+ 
  theme(strip.background=element_rect(fill="white"))+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))+
  labs( x='PCA 1', y='PCA 2' )
```

##### PCA per Joint

```{r PlotFacetPCA2, fig.height=5, fig.width=15}
plotReducedDim(sce, dimred="PCA_reduced", colour_by="Sample",point_alpha=0.8,point_size=0.1) + 
  facet_wrap(~sce$Joint.Location)+ 
  theme(strip.background=element_rect(fill="white"))+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))+
  labs( x='PCA 1', y='PCA 2' )
```


#### PCA-level metrics

The plot below shows, for each of the PCs, the variance explained by the variables in colData(sce) that are most strongly associated with the PCs. The sample_id variable: it has a unique value for each cell, so can explain all the variation for all PCs.

```{r PCAMetrics}
explanPc <- getExplanatoryPCs(sce,dimred = "PCA",n_dimred=25,variables = c(
      "sum","detected","subsets_Mito_percent","Sample","Joint.Location","Pathotype","GCTreatment","Seropositivity","Protocol"))

plotExplanatoryPCs(explanPc) 
```


### Perform Uniform Manifold Approximation and Projection

While PCA can only capture linear transformations of the original variables (genes), UMAP performs a non-linear transformation of the data to project it down to lower dimensions. This preserves both local and global structures.

```{r RunUMAP}
#Run UMAP
sce <- runUMAP(sce,name = "UMAP", dimred = "PCA_reduced", subset_row = top.hvgs)

```


#### Plot UMAP  {.tabset}

##### Colored by Sample

```{r PlotUMAP1}
plotReducedDim(sce, dimred="UMAP", colour_by="Sample",point_alpha=0.7,point_size=0.1)+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  labs( x='UMAP 1', y='UMAP 2' )+
  guides(colour = guide_legend(override.aes = list(size=2)))
```

##### Colored by Joint

```{r PlotUMAP2}
plotReducedDim(sce, dimred="UMAP", colour_by="Joint.Location",point_alpha=0.7,point_size=0.1)+
  scale_colour_manual( values=meta_colors$Joint.Location,name = "Joint.Location" )+ 
  labs( x='UMAP 1', y='UMAP 2' )+
  guides(colour = guide_legend(override.aes = list(size=2)))#+ facet_wrap(~sce$Sample)
```


#### Plot UMAP Facet {.tabset}

##### Facet by Sample


```{r PlotFacetUMAP1,fig.height=10, fig.width=15}
#Plot PCA per sample
plotReducedDim(sce, dimred="UMAP", colour_by="Sample",point_alpha=0.8,point_size=0.5) + 
  facet_wrap(~sce$Sample)+ 
  theme(strip.background=element_rect(fill="white"))+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))
```


##### Facet by Joint

```{r PlotFacetUMAP2, fig.height=5, fig.width=12}
plotReducedDim(sce, dimred="UMAP", colour_by="Sample",point_alpha=0.8,point_size=0.1) + 
  facet_wrap(~sce$Joint.Location)+ 
  theme(strip.background=element_rect(fill="white"))+
  scale_colour_manual( values=meta_colors$nice_cols[seq.int(length(unique(sce$Sample)))],name = "Sample" )+ 
  guides(colour = guide_legend(override.aes = list(size=2)))
```


#### Plot UMAP with QC metrics {.tabset}

Check if there is any clustering caused by number of counts, genes or mitochondrial content. This might also give information about the cell type associated with a cluster.

##### Colored by Mitochondrial Genes

```{r PlotQcUMAP1}
#Plot UMAP colored by subsets_Mito_percent
plotReducedDim(sce, dimred="UMAP", colour_by="subsets_Mito_percent",order_by="subsets_Mito_percent",point_alpha=0.8,point_size=0.5) + 
  ggtitle("Mitochondrial Genes")+
  labs( x='UMAP 1', y='UMAP 2' )+
  scale_color_viridis(option="magma")

```

##### Colored by nr of Genes

```{r PlotQcUMAP2}
#Plot UMAP colored by detected
plotReducedDim(sce, dimred="UMAP", colour_by="detected",order_by="detected",point_alpha=0.8,point_size=0.5) + 
  ggtitle("Number of detected Genes ")+
  labs( x='UMAP 1', y='UMAP 2' )+
  scale_color_viridis(option="magma")

```

##### Colored by nr of Counts

```{r PlotQcUMAP3}
#Plot UMAP colored by sum
plotReducedDim(sce, dimred="UMAP", colour_by="sum", order_by = "sum",point_alpha=0.8,point_size=0.5) + 
  ggtitle("Sum of UMI Counts in Cell")+
  labs( x='UMAP 1', y='UMAP 2' )+
  scale_color_viridis(option="magma")
```

##### Colored by Ribosomal Genes

```{r PlotQcUMAP4}
#Plot UMAP colored by subsets_Mito_percent
plotReducedDim(sce, dimred="UMAP", colour_by="subsets_Ribo_percent",order_by="subsets_Ribo_percent",point_alpha=0.8,point_size=0.5) + 
  ggtitle("Ribosomal Genes")+
  labs( x='UMAP 1', y='UMAP 2' )+
  scale_color_viridis(option="magma")

```


##### Colored by Ubi Markergene

```{r PlotQcUMAP5}
#Plot UMAP colored by Ubi Markergene expression
plotReducedDim(sce, dimred="UMAP", by_exprs_values = "logcounts", colour_by= rownames(sce)[grepl("(^B2M)", rowData(sce)$Symbol)],point_alpha=0.8,point_size=0.1)+ 
  ggtitle("Expression of some Ubi Markergene")+
  labs( x='UMAP 1', y='UMAP 2' )+
  scale_color_viridis(option="magma")
```

## Save Dataset

```{r SaveData}
saveRDS(sce, file =paste0(path,'/output/02_sce_DimensionalityReduction.rds'))
```
