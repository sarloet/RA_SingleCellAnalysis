---
title: "QC and Preprocessing"
subtitle: "01_Preprocessing"
author: "SarahL."
date: "`r format(Sys.time(), '%b %e %Y %H:%M:%S')`"
output: 
  html_document:
    toc: true
    number_sections: true   
    toc_float: true
    code_folding: show
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = FALSE, cache.lazy = FALSE)
knitr::opts_chunk$set(dpi = 300, fig.align = "center")
knitr::opts_chunk$set(out.width = "100%", out.height = "100%")
```



# Quality Controll and Preprocessing

## Setup

### Load Packages

```{r LoadPackages, warning=FALSE}
#Load Packages

suppressPackageStartupMessages({
library(BiocParallel)
library(ggplot2) 
library(dplyr)
library(scater)
library(scran)
library(DropletUtils)
library(gridExtra)
library(scDblFinder)
})

```

### Set parameter

```{r Setup}
set.seed(100)
bpp <- BiocParallel::MulticoreParam(parallel::detectCores()-1)
path <- "/Volumes/Elements/Masterthesis/RA_SingleCellAnalysis/"
```


## Load Data

```{r LoadDataset}
## Load the RA DATASET
sce <- readRDS(file = paste0(path,'output/00_sce_DataPreparation.rds'))

```


### Explore Dataset Dimensions

```{r ShowDim}
#Dimensions of count matrix
dim(sce)
```

### Histogramm with number of cells {.tabset}

Show the number of cells detected in each sample or joint location before filtering

#### Per Sample

```{r PlotCellsPerSample}
#Histogramm with number of cells per sample
ggplot(colData(sce), aes(x=Sample))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per sample") 
data.frame(as.list(table(colData(sce)$Sample)))

```

#### Per Joint Location

```{r PlotCellsJoint}
#Histogramm with number of cells per sample
ggplot(colData(sce), aes(x=Joint.Location))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per sample") 
data.frame(as.list(table(colData(sce)$Joint.Location)))
```


## Initial filtering

Initial filtering to remove unexpressed genes and cells with very low number of counts. The input to scDblFinder should not include empty droplets, and it might be necessary to remove cells with a very low coverage (e.g. <200 reads) to avoid errors. Further quality filtering should be performed downstream of doublet detection.

```{r InitialFiltering}
#Initial filtering before droplet removal
dim_before_filtering <- dim(sce)

#Get only the detected Genes
detected_genes <- rowSums(counts(sce)> 0)
detected_cells <- colSums(counts(sce)> 0)

#Remove Genes not expressed in at least 10 Cells & Cells with less than 150 genes expressed
#sce <- sce[detected_genes > 10, detected_Cells >200]

#Remove Cells with very low expression of less than 200 genes expressed and genes not expressed
sce <- sce[detected_genes > 0, detected_cells > 200]


dim_after_filtering <- dim(sce)

cat("NR of Cells Before Initial Filtering ", dim_before_filtering[2],
    "\nNR of Cells After Initial Filtering ", dim_after_filtering[2],
    "\nNR of Cells Filtered out ", dim_before_filtering[2] - dim_after_filtering[2],
    
    "\n\nNR of Genes Before Initial Filtering ", dim_before_filtering[1],
    "\nNR of Genes After Initial Filtering ", dim_after_filtering[1],
    "\nNR of Genes Filtered out ", dim_before_filtering[1] - dim_after_filtering[1]
    )

```

## Doublet detection

Doublets are defined as two cells that are sequenced under the same cellular barcode, which happens if they were captured in the same droplet. The scDblFinder method combines the strengths of various doublet detection approaches, training an iterative classifier on the neighborhood of real cells and artificial doublets.

```{r DoubletDetection}
#Detection
sce <- scDblFinder::scDblFinder(sce, samples="Sample", BPPARAM = bpp) 

table(sce$scDblFinder.class)
table(sce$Sample,sce$scDblFinder.class)

```

```{r DoubletDetectionPlots}
#Plot singlet/doublet histogramm

print(as.data.frame(colData(sce)) %>%
  dplyr::group_by(Sample, scDblFinder.class) %>%
  dplyr::summarise(counts=n()) %>%
  ggplot(aes(x=Sample, y=counts, fill=scDblFinder.class)) + 
  geom_bar(stat="identity") +
    labs(title="Doublet detection results",
    subtitle="By sample") +
    theme(axis.text.x = element_text(angle = 45,hjust=1), axis.ticks.x=element_blank()))

#Plot singlet/doublet qcplots
colData(sce) %>% 
    as.data.frame() %>% 
    arrange(scDblFinder.class) %>% 
    ggplot(aes(x = sum, y = detected)) +
      geom_point(aes(colour = scDblFinder.class)) + 
      facet_wrap(vars(Sample))+ 
      ggtitle("Total number of detected genes plotted against total number of UMIs") 

colData(sce) %>% 
    as.data.frame() %>% 
    arrange(scDblFinder.class) %>% 
    ggplot(aes(x = sum, y = subsets_Mito_percent)) +
      geom_point(aes(colour = scDblFinder.class)) + 
      facet_wrap(vars(Sample))+ 
      ggtitle("Percentage of mitochondrial UMIs plotted against total number of UMIs") 



```

```{r DoubletRemoval}
#Apply Doublet Removal
print(paste0("NR of Cells Before Doublet Removal ", dim(sce)[2]))
sce <- sce[ ,sce$scDblFinder.class == "singlet"]
print(paste0("NR of Cells Before Doublet Removal ", dim(sce)[2]))

```

## Filter Cells


```{r CalcQcMetrics}
# Indentify mitochondrial genes
is_mito<- grepl("(^MT-)|(^mt-)", rowData(sce)$Symbol)
rowData(sce)$Symbol[is_mito] #Show the MT genes

# calculate per-cell quality control (QC) metrics using scater
sce <- addPerCellQC(sce, subsets=list(Mito=is_mito))
```


```{r FixedThresholds}
#Some Fixed thresholds
colData(sce)$qc.count_manual <- sce$sum < 1000 # Cells have at least a count of 750
colData(sce)$qc.genexp_manual <- sce$detected < 500 # Cells have at least 500 genes expressed
colData(sce)$qc.mito_manual <- sce$subsets_Mito_percent > 15 #Mitochondrial contamination has to be lower than 15%

```

```{r AdaptiveThresholds}
#With Adaptive thresholds (for each batch/sample)

colData(sce)$qc.count <- isOutlier(sce$sum,nmads=3, log=TRUE, type="lower",batch =sce$Sample )
attr(colData(sce)$qc.count, "thresholds") # Cells with very low number of counts

colData(sce)$qc.genexp <- isOutlier(sce$detected,nmads=3, log=TRUE, type="lower",batch =sce$Sample)
attr(colData(sce)$qc.genexp, "thresholds") # Cells with very low number of genes

colData(sce)$qc.mito <- isOutlier(sce$subsets_Mito_percent, type="higher",batch =sce$Sample)
attr(colData(sce)$qc.mito, "thresholds") # Cells with high mitochondrial content



colData(sce)$discard <- sce$qc.count | sce$qc.count_manual | sce$qc.genexp | sce$qc.genexp_manual | sce$qc.mito | sce$qc.mito_manual

```

```{r QcSummary}

# Summary of all discarted cells
data.frame(`Library_size` = sum(sce$qc.count | sce$qc.count_manual),
           `Genes_detected` = sum(sce$qc.genexp| sce$qc.genexp_manual),
           `Mitochondrial_percentage` = sum(sce$qc.mito| sce$qc.mito_manual),
           Total_discarded = sum(sce$discard))

```


### QC filtering Plots

The aim by plotting the proportion of mitochondrial counts against some of the other QC metrics is to confirm that there are no cells with both large total counts and large mitochondrial counts, to ensure that we are not inadvertently removing high-quality cells that happen to be highly metabolically active (e.g., hepatocytes).

```{r QcPlots}
# QCplots after filtering whole dataset

colData(sce) %>% 
    as.data.frame() %>% 
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = detected, colour = discard)) +
      geom_point() + ggtitle("Total number of detected genes plotted against total number of UMIs") 

colData(sce) %>% 
    as.data.frame() %>%
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = subsets_Mito_percent, colour = discard)) +
      geom_point()+ ggtitle("Percentage of mitochondrial UMIs plotted against total number of UMIs") 

```

```{r QcPlots}
#Plot Total count
p1<-plotColData(sce, y="sum",colour_by = "discard") + scale_y_log10() + ggtitle("Total count") +guides(colour=guide_legend(title="Discarded"))

#Plot Detected Feaututes
p2<-plotColData(sce, y="detected",colour_by = "discard") + scale_y_log10() + ggtitle("Detected features") +guides(colour=guide_legend(title="Discarded"))

#Plot Mito percent
p3<-plotColData(sce, y="subsets_Mito_percent",colour_by = "discard") + ggtitle("Mito percent") +guides(colour=guide_legend(title="Discarded"))

grid.arrange(p1, p2, p3, nrow = 1, ncol = 3)
```

```{r QcPlots}
#Look at samples individually

colData(sce) %>% 
    as.data.frame() %>% 
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = detected)) +
      geom_point(aes(colour = discard)) + 
      facet_wrap(vars(Sample))+ 
      ggtitle("Total number of detected genes plotted against total number of UMIs") 

colData(sce) %>% 
    as.data.frame() %>% 
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = subsets_Mito_percent)) +
      geom_point(aes(colour = discard)) + 
      facet_wrap(vars(Sample))+ 
      ggtitle("Percentage of mitochondrial UMIs plotted against total number of UMIs") 


```

```{r QcPlots}
#Look at samples individually

#Plot Total count
p1<-plotColData(sce, x="Sample", y="sum",other_fields="Sample",colour_by = "discard") + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") + 
    scale_y_log10() + 
    ggtitle("Total count")+
    guides(colour=guide_legend(title="Discarded"))

#Plot Detected Feaututes
p2<-plotColData(sce, x="Sample", y="detected", other_fields="Sample",colour_by = "discard") + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") + 
    scale_y_log10() + 
    ggtitle("Detected features")+
    guides(colour=guide_legend(title="Discarded"))

#Plot Mito percent
p3<-plotColData(sce, x="Sample", y="subsets_Mito_percent", other_fields="Sample",colour_by = "discard") + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") +
    ggtitle("Mito percent")+
    guides(colour=guide_legend(title="Discarded"))

grid.arrange(p1, p2, p3, nrow = 3)

```

```{r QcPlots}
#Cells marked to be dropped per samples

# Relative comparison / by sample
as.data.frame(colData(sce)) %>%
  group_by(Sample, discard) %>%
  summarise(Freq=n()) %>% 
  ggplot(aes(x=Sample, y=Freq, fill=discard, label=Freq)) +
         geom_bar(stat="identity", position="fill") +
  labs(title="Cells to be dropped",
       subtitle="Labels represent absolute number of cells",
       x="",
       y="Number of cells") + 
  geom_text(size=3.5, position = position_fill(vjust=0.5)) 

# Absolute comparison / by sample
as.data.frame(colData(sce)) %>%
  group_by(Sample, discard) %>%
  summarise(Freq=n()) %>% 
  ggplot(aes(x=Sample, y=Freq, fill=discard, label=Freq)) +
         geom_bar(stat="identity", position="stack") +
  labs(title="Cells to be dropped",
       subtitle="Labels represent absolute number of cells",
       x="",
       y="Number of cells") + 
  geom_text(size=3.5, position = position_stack(vjust=0.5)) 

```

### Apply filtering
```{r}
# Create the filtered sce element
sce.filtered <- sce[, !colData(sce)$discard]

```


## Filter Genes

```{r GeneFiltering}

#Filter out genes 
dim_before_filtering <- dim(sce)

#Get only the detected Genes
detected_genes <- rowSums(counts(sce)> 0)

#Remove Genes not expressed in at least 10 Cells 
sce <- sce[detected_genes > 10,]


dim_after_filtering <- dim(sce)

cat("NR of Cells Before Initial Filtering ", dim_before_filtering[2],
    "\nNR of Cells After Initial Filtering ", dim_after_filtering[2],
    "\nNR of Cells Filtered out ", dim_before_filtering[2] - dim_after_filtering[2],
    
    "\n\nNR of Genes Before Initial Filtering ", dim_before_filtering[1],
    "\nNR of Genes After Initial Filtering ", dim_after_filtering[1],
    "\nNR of Genes Filtered out ", dim_before_filtering[1] - dim_after_filtering[1]
    )

```


## Cells after filtering

```{r PlotCellsPerSampleAfterFiltering}
#Histogramm with number of cells per sample after filtering
ggplot(colData(sce.filtered), aes(x=Sample))+geom_bar()+ coord_flip()+ggtitle("Number of cells per sample")

```

```{r PlotCellsPerJointAfterFiltering}
#Histogramm with number of cells per sample after filtering
ggplot(colData(sce.filtered), aes(x=Joint.Location))+geom_bar()+ coord_flip()+ggtitle("Number of cells per Joint")

```

```{r PlotTop25GenesAfterFiltering}
#Check top 20 expressed genes after filtering

rel_expression <- t( t(counts(sce.filtered)) / colSums(counts(sce.filtered))) * 100
rownames(rel_expression) <- rowData(sce.filtered)$Symbol
most_expressed <- sort(rowSums( rel_expression ),T)[20:1]
plot_data <- as.matrix(t(rel_expression[names(most_expressed),]))

boxplot(plot_data, cex=0.1, las=1, xlab="% total count per cell", horizontal=TRUE, main="Distribution of counts for the top 20 genes before filtering")
```

## Normalization

```{r}
# Library size?

hist(sce$total,breaks = 100)
```

```{r}
# calculate per-cell quality control (QC) metrics using scater

hist(data.frame(colData(sce))$detected,breaks = 100)
```

### Library size normalization
```{r}
# Library size normalization
sce.lib <- computeLibraryFactors(sce.filtered)


ggplot(data.frame("log10libSf"=log10(sizeFactors(sce.lib))), aes(x=log10libSf)) +xlab("Log10 Library size factor") + geom_histogram(bins=50)+ggtitle("Distribution of size factors")
```


### Normalization by deconvolution

```{r}
# Normalization by deconvolution
clust.filtered <- quickCluster(sce.filtered) #block=factor(sce.filtered$Protocol)
table(clust.filtered)

sce.deconv <- computeSumFactors(sce.filtered,clusters=clust.filtered)
```

```{r}
print("Library size factors")
summary(sizeFactors(sce.lib))
print("Deconvolution size factors")
summary(sizeFactors(sce.deconv))

#Deconvolution size factor for each cell in the dataset, compared to the equivalent size factor derived from the library size. The red line corresponds to identity between the two size factors. 
plot(unname(sizeFactors(sce.lib)), sizeFactors(sce.deconv), xlab="Library size factor",ylab="Deconvolution size factor", log='xy', pch=16,col=as.integer(factor(clust.filtered)), main="Deconvolution factors for individual cluster")
abline(a=0, b=1, col="red")

#Color by sample
plot(unname(sizeFactors(sce.lib)), sizeFactors(sce.deconv), xlab="Library size factor",ylab="Deconvolution size factor", log='xy', pch=16,col=as.integer(factor(sce.filtered$Sample)), main="Deconvolution factors for individual Sample")
abline(a=0, b=1, col="red")

#Color by protocol
#plot(unname(sizeFactors(sce.lib)), sizeFactors(sce.deconv), xlab="Library size factor",ylab="Deconvolution size factor", log='xy', pch=16,col=as.integer(factor(syn_sce_tidy_filtered$Protocol)), main="Deconvolution factors for individual Protocol")
#abline(a=0, b=1, col="red")

```

### Normalization with variance stabilising transformation

```{r}
# Normalization with variance stabilising transformation
counts <- counts(sce)
vst_out <- vst(umi = counts,latent_var = 'log_umi',return_gene_attr = TRUE,return_cell_attr = TRUE)

```



```{r}
# Apply Normalisation
sce.filtered <- logNormCounts(sce.deconv)
summary(sizeFactors(sce.filtered))
assayNames(sce.filtered)

#Check that the model used is the one we want (regressing out the effect of library size).
print(vst_out$model_str)

#The distribution of residual mean should be centered around 0
ggplot(vst_out$gene_attr, aes(residual_mean)) +
  geom_histogram(binwidth=0.01)

#The distribution of residual variance should be centered around 1
ggplot(vst_out$gene_attr, aes(residual_variance)) +
  geom_histogram(binwidth=0.1) +
  geom_vline(xintercept=1, color='red') +
  xlim(0, 10)

#Finally, check that the relationship between variance and mean has been removed
ggplot(vst_out$gene_attr,
       aes(log10(gmean), residual_variance)) +
       geom_point(alpha=0.3, shape=16)

```

## Variable-level metrics

Variable-level metrics are computed by the getVarianceExplained() function. This calculates the percentage of variance of each gene’s expression that is explained by each variable in the colData of the SingleCellExperiment object. We can then use this to determine which experimental factors are contributing most to the variance in expression. This is useful for diagnosing batch effects or to quickly verify that a treatment has an effect.

```{r}
vars <- getVarianceExplained(sce.filtered,assay.type="logcounts",
    variables=c("Sample", "Joint.Location", "sex", "Age"))
head(vars)

plotExplanatoryVariables(vars)
```


## Save the dataset

```{r SaveData}
saveRDS(sce.filtered, file =paste0('/Volumes/Elements/Masterthesis/RA_SingleCellAnalysis/output/','01_sce_Preprocessing.rds'))
```
