---
title: "Differential Expression Analysis"
subtitle: "07_DifferentialExpression_MAST"
author: "SarahL."
date: "`r format(Sys.time(), '%b %e %Y %H:%M:%S')`"
output: 
  html_document:
    toc: true
    number_sections: true   
    toc_float: true
    code_folding: hide
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(cache = FALSE, cache.lazy = FALSE)
knitr::opts_chunk$set(dpi = 300, fig.align = "center")
knitr::opts_chunk$set(out.width = "100%", out.height = "100%")
```


# Differential Expression Analysis

## Setup

### Standard packages

```{r LoadPackages, warning=FALSE}
library(here)
source(here("code", "standard_libraries.R"))
```

### Additional Packages


```{r LoadPackages, warning=FALSE}
#Load Packages

suppressPackageStartupMessages({
library(MAST)
library(EnhancedVolcano)
})

```

### Set Parameter

```{r Setup}
set.seed(123)
bpp <- BiocParallel::MulticoreParam(parallel::detectCores()-1, RNGseed=100)
path <- here::here()
```


### Load Data

```{r LoadDataset}
## RA DATASET
sce <- readRDS(file = paste0(path,'/output/05_sce_CelltypeAnnotation.rds'))

```


### Explore Dataset

```{r ShowDim}
#Dimensions of count matrix
dim(sce)
```

https://mperalc.gitlab.io/scRNA-seq_workshop_2021/additional-resources.html## UMAPs coloured by cluster or cell type

### Plot Clustering and Annotation {.tabset}

### Annotation

```{r UMAPAnnotation}
#cell type
plotReducedDim(sce, "MNN_UMAP_reduced", colour_by="celltype", text_by="celltype") +labs(title="UMAP colored by Cell type ",subtitle = "UMAP of all integrated datasets")

```

### Clusters

```{r UMAPCluster}
#cluster
plotReducedDim(sce, "MNN_UMAP_reduced", colour_by="cluster", text_by="cluster") +labs(title="UMAP colored by clusters",subtitle = "UMAP of all integrated datasets")

```

## Differential Expression with MAST

MAST framework models single-cell gene expression using a two-part generalized linear model. One component of MAST models the discrete expression rate of each gene across cells, while the other component models the conditional continuous expression level (conditional on the gene being expressed). 

### MAST function

```{r }
#Function find_de_MAST takes a SingleCellExperiment object as input with two conditions to test (cond1 vs cond2)and runs MAST with RE pipeline. The output of the function is a table (pandas DataFrame in Python) which contains results of the analysis, e.g. log-fold change, p-value and FDR-corrected value for each gene.

find_de_MAST <- function(sce,cond1,cond2){
    set.seed(123)
    # Subset for conditions and create a MAST object
    sce.subset <- sce.subset[,sce.subset$Joint.Location == c(cond1, cond2)]
    sca <- suppressMessages(SceToSingleCellAssay(sce.subset, class = "SingleCellAssay", check_sanity = TRUE)) # create a MAST object
    
    # keep genes that are expressed in more than 10% of all cells
    print("Dimensions before filtering genes:")
    print(dim(sca))
    sca <- sca[freq(sca)>0.1,]
    print("Dimensions after filtering genes:")
    print(dim(sca))
    
    # add a column to the data which contains scaled number of genes that are expressed in each cell
    cdr2 <- colSums(assay(sca)>0)
    colData(sca)$ngeneson <- scale(cdr2)

    # same for donors (which we need to model random effects)
    colData(sca)$replicate <- factor(colData(sca)$Sample)
    # create a group per condition-celltype combination
    colData(sca)$group <- factor(colData(sca)$Joint.Location)
    # define and fit the model
    options(mc.cores = 4)
    zlmCond <- zlm(formula = ~ngeneson + group + (1 | replicate), 
                   sca=sca, 
                   method='glmer', 
                   ebayes=F, 
                   strictConvergence=F,
                   parallel = TRUE,
                   exprs_value = 'logcounts',
                   fitArgsD=list(nAGQ = 0)) # to speed up calculations
    
    # perform likelihood-ratio test for the condition that we are interested in    
    summaryCond <- MAST::summary(zlmCond, doLRT=paste0('group',cond2))
    
    # get the table with log-fold changes and p-values
    summaryDt <- summaryCond$datatable
    result <- merge(summaryDt[contrast== paste0('group',cond2) & component=='H', .(primerid, `Pr(>Chisq)`)], # p-values
                     summaryDt[contrast== paste0('group',cond2) & component=='logFC', .(primerid, coef)],# logFC coefficients
                     by='primerid') 
    
    # MAST uses natural logarithm so we convert the coefficients to log2 base to be comparable to edgeR
    result[,log2FoldChange:=result[,coef]/log(2)]
    
    # do multiple testing correction
    result[,FDR:=p.adjust(`Pr(>Chisq)`, 'fdr')]
    data.table::setorder(result, FDR)
    
    #Rename
    names(result)[names(result) == "Pr(>Chisq)"] <- "PValue"
     
    # omit possible NA
    result <- stats::na.omit(as.data.frame(result))
    
    return(result)
}
```

### Run MAST

#### Fibroblast 

```{r SaveData}
sce.subset <- sce[,sce$celltype == "Fibroblast"]
```

##### Run Function

```{r SaveData}
##### Knee vs MCPs
res_KneeVsMCP <- find_de_MAST(sce.subset,cond1="Knee",cond2="MCP")
##### Knee vs Wrist
res_KneeVsWrist <- find_de_MAST(sce.subset,cond1="Knee",cond2="Wrist")
#### MCP vs Wrist
res_MCPVsWrist <- find_de_MAST(sce.subset,cond1="MCP",cond2="Wrist")

```


## Show and Plot Result of DEG


### Show tables

```{r SaveData,  results='asis', out.width = '30%',fig.height = 7}
for (comp in c("KneeVsMCP","KneeVsWrist","MCPVsWrist")){
  
  cat(paste0("#### ", comp, "\n"))
  
  res<-eval(parse(text = paste0("res_",comp)))
  
  table<- res[res$PValue<0.05 & abs(res$log2FoldChange) > 0.1,, drop=F]
  print(table)
  dim(table)
  
  cat(' \n')
}

```

### Volcano plot

```{r SaveData,  results='asis', out.width = '30%',fig.height = 7}
for (comp in c("KneeVsMCP","KneeVsWrist","MCPVsWrist")){
  
  cat(paste0("#### ", comp, "\n"))
  
  #Create dd for plotting function
  res_plot<-eval(parse(text = paste0("res_",comp)))
  
  row.names(res_plot)<- res_plot$primerid
  res_plot <- res_plot[,c("PValue","log2FoldChange")]
    
  strspl<-strsplit(comp, split = "Vs")#
  
  #Create dd for plotting function
  volcano_plot<-EnhancedVolcano(res_plot, lab = row.names(res_plot), x = 'log2FoldChange', y = 'PValue',
                  pCutoff = 0.05, FCcutoff = 0.5,
                  title = paste("Differential expression", strspl[[1]][1], "vs", strspl[[1]][2], sep=' '),
                  subtitle = paste0("Fibroblast"," cluster (MAST)"),
                  pointSize = 1.0, colAlpha = 1,
                  legendPosition = 'right',
                  gridlines.major = FALSE,
                  gridlines.minor = FALSE)+
                  scale_y_continuous(expand = c(0,0))+
                  scale_x_continuous(expand = c(0.1,0))
    
  print(volcano_plot)
  cat(' \n')
}

```

### Heatmap

```{r SaveData, results='asis'}
library(ComplexHeatmap)
#select top denes

for (comp in c("KneeVsMCP","KneeVsWrist","MCPVsWrist")){
  
  cat(paste0("#### ", comp, "\n"))
  
  res <- get(paste0("res_",comp))
  
  # Get top significant marker genes
  res_sig <- res[res$PValue<0.01 & abs(res$log2FoldChange)> 0.1,, drop=F] #genes for cond1
  data.table::setorder(res_sig, PValue)
  res_sig<-head(res_sig,n=25)
  
  # Subset sce to keep the tested conditions
  strspl<-strsplit(comp, split = "Vs")#
  sce.subset.Joint<-sce.subset[,sce.subset$Joint.Location == c(strspl[[1]][1], strspl[[1]][2])]
  
  # Aggregate cells by sample and subset for significant genes
  sce.subset.aggr <- aggregateAcrossCells(sce.subset.Joint,  ids = sce.subset.Joint$Sample, statistics = "mean",use.assay.type = "logcounts", subset.row = res_sig$primerid)
  
  # Create Z-score
  mat<-logcounts(sce.subset.aggr)
  mat.z <- t(apply(mat,1,scale))
  # Add colnames for Heatmap
  colnames(mat.z) <- unique(paste0(sce.subset.aggr$Sample,":",sce.subset.aggr$Joint.Location))
  
  # Plot heatmap
  heatmap_plot <- Heatmap(
    mat.z,cluster_rows = T,cluster_columns = T, 
    column_labels = sapply(strsplit(colnames(mat.z), split = ":"), "[[", 1),#colnames(mat.z),
    name="Z-score",
    column_title=paste("Differential expression", strspl[[1]][1], "vs", strspl[[1]][2], sep=' '),
    top_annotation = HeatmapAnnotation(Joint.Location = sapply(strsplit(colnames(mat.z), split = ":"), "[[", 2),
                                       col = list(Joint.Location = c("Knee" = "#00bfff", "MCP" = "#FB8072", "Wrist" = "#33A02C"))))

  print(heatmap_plot)
   
   cat(' \n')
}
 
```


## Save the datasets

```{r SaveData}
write.csv(res_KneeVsMCP, paste0(path,'/output/MAST_KneeVsMCP.csv'), row.names=FALSE)
write.csv(res_KneeVsWrist, paste0(path,'/output/MAST_KneeVsWrist.csv'), row.names=FALSE)
write.csv(res_MCPVsWrist, paste0(path,'/output/MAST_MCPVsWrist.csv'), row.names=FALSE)
```
