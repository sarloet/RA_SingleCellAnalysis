---
title: "Quality Control and Filtering"
subtitle: "01_QualityControl"
author: "SarahL."
date: "`r format(Sys.time(), '%b %e %Y %H:%M:%S')`"
output: 
  html_document:
    toc: true
    number_sections: true   
    toc_float: true
    code_folding: show
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
knitr::opts_chunk$set(cache = FALSE, cache.lazy = FALSE)
knitr::opts_chunk$set(dpi = 300, fig.align = "center")
knitr::opts_chunk$set(out.width = "100%", out.height = "100%")
```


# Quality Control and Preprocessing

## Setup

### Standard packages
```{r LoadPackages, warning=FALSE}
library(here)
source(here("code", "standard_libraries.R"))
```

### Additional Packages
```{r LoadAddPackages, warning=FALSE}
#Load Packages
suppressPackageStartupMessages({
library(grid)
})

```

### Set Parameter
```{r Setup}
set.seed(123)
bpp <- BiocParallel::MulticoreParam(parallel::detectCores()-1, RNGseed=123)
path <- here::here()
```

## Load Data

```{r LoadDataset}
## Load the RA DATASET
sce <- readRDS(file = paste0(path,'/output/00_sce_DataPreparation.rds'))
```

### Explore Dataset Dimensions
```{r ShowDim}
#Dimensions of count matrix
dim(sce)
```


### Histogramm with number of cells {.tabset}

Show the number of cells detected in each sample or joint location before filtering

#### Per Sample

```{r PlotCellsPerSample}
#Histogramm with number of cells per Sample
ggplot(colData(sce), aes(x=Sample))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per sample") + 
  theme_classic()+
  stat_count(geom = "text", colour = "white", size = 3.5,aes(label = ..count..),position=position_stack(vjust=0.65))+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())+
  scale_y_continuous(expand = c(0,0))

data.frame(as.list(table(colData(sce)$Sample)))
```

#### Per Joint Location

```{r PlotCellsJoint}
#Histogramm with number of cells per Joint
ggplot(colData(sce), aes(x=Joint.Location))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per Joint") + 
  theme_classic()+
  stat_count(geom = "text", colour = "white", size = 3.5,aes(label = ..count..),position=position_stack(vjust=0.8))+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())+
  scale_y_continuous(expand = c(0,0))

data.frame(as.list(table(colData(sce)$Joint.Location)))
```


## Filter Cells

The main goal of quality control is to remove low-quality reads from the dataset. When a cell has a low number of detected genes, a low count depth and a high fraction of mitochondrial counts it might have a broken membrane which can indicate a dying cell. 

We filter for:
- Low and high number of counts per barcode (count depth)
- Low and high number of genes per barcode
- High fraction of counts from mitochondrial genes per barcode
- High fraction of counts from HBB genes per barcode (erythrocytes)

```{r CalcQcMetrics}
# Indentify mitochondrial genes
is_mito<- grepl("(^MT-)|(^mt-)", rowData(sce)$Symbol)
cat("Mitochondrial genes:", rowData(sce)$Symbol[is_mito]) #Show the MT genes

# Indentify HBB genes
is_hbb<- grepl("(^HBB)|(^hbb)", rowData(sce)$Symbol)
cat("HBB genes:", rowData(sce)$Symbol[is_hbb]) #Show the HBB genes

# Indentify Ribosomal genes
is_ribo<- grepl("(^RPL)|(^RPS)|(^rpl)|(^rps)", rowData(sce)$Symbol) 
cat("Ribosomal genes:", rowData(sce)$Symbol[is_ribo])#Show the Ribo genes

# calculate per-cell quality control (QC) metrics using scater
sce <- addPerCellQC(sce, subsets=list(Mito=is_mito, Hbb=is_hbb, Ribo=is_ribo))
```

### Fixed Filtering Thresholds

```{r FixedThresholds}
#Some Fixed thresholds
colData(sce)$qc.count_manual <- sce$sum < 400 |sce$sum > 100000 # Cells have at least a count of 400 |sce$sum > 100000
colData(sce)$qc.genexp_manual <- sce$detected < 300 | sce$detected > 10000  # Cells have at least 300 genes expressed 
colData(sce)$qc.mito_manual <- sce$subsets_Mito_percent > 15 #Mitochondrial contamination has to be lower than 15%
colData(sce)$qc.hbb_manual <- sce$subsets_Hbb_percent > 5 #Remove cells expressing HBB (erythrocytes)

```

```{r SumHisto}
#Some Fixed thresholds
hist(sce$total,breaks = 100,main ="UMI distribution",xlab ="UMI")
abline(v = 400, col = "red")
abline(v = 100000, col = "red")

```

```{r DetectedHisto}
#Some Fixed thresholds
hist(sce$detected,breaks = 100, main ="Detected gene distribution",xlab ="Detected")
abline(v = 300, col = "red")
abline(v = 10000, col = "red")
```


### Adaptive Filtering Thresholds (for each batch/sample)

```{r AdaptiveThresholds}

# Detect cells with very low number of counts
colData(sce)$qc.count <- isOutlier(sce$sum,nmads=3, log=TRUE, type="both",batch =sce$Sample )
data.frame(t(attr(colData(sce)$qc.count, "thresholds")))

# Detect cells with very low number of genes
colData(sce)$qc.genexp <- isOutlier(sce$detected,nmads=3, log=TRUE, type="both",batch =sce$Sample)
data.frame(t(attr(colData(sce)$qc.genexp, "thresholds")))

# Detect cells with high mitochondrial content
colData(sce)$qc.mito <- isOutlier(sce$subsets_Mito_percent,nmads=3, type="higher",batch =sce$Sample)
data.frame(t(attr(colData(sce)$qc.mito, "thresholds"))) 


# Mark all Cells to be Discarted
colData(sce)$discard <- sce$qc.count | sce$qc.count_manual | sce$qc.genexp | sce$qc.genexp_manual | sce$qc.mito | sce$qc.mito_manual | sce$qc.hbb_manual


```

```{r QcSummary}

# Summary of all discarted cells
t(data.frame(`Library_size` = sum(sce$qc.count | sce$qc.count_manual),
           `Genes_detected` = sum(sce$qc.genexp| sce$qc.genexp_manual),
           `Mitochondrial_percentage` = sum(sce$qc.mito| sce$qc.mito_manual),
           `HBB_expression` = sum(sce$qc.hbb_manual),
           Total_discarded = sum(sce$discard)))

```


### QC Filtering Plots

The aim by plotting the proportion of mitochondrial counts against some of the other QC metrics is to confirm that there are no cells with both large total counts and large mitochondrial counts, to ensure that we are not inadvertently removing high-quality cells that happen to be highly metabolically active (e.g., hepatocytes).

#### Scatter Plots Per Sample {.tabset}

##### Detected genes vs total number of UMIs

```{r QcPlots1}
colData(sce) %>% 
    as.data.frame() %>% 
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = detected)) +
      geom_point(aes(colour = discard),size=0.5) + 
      facet_wrap(vars(Sample))+
      labs(title="Total number of detected genes plotted against total number of UMIs",
       x="Total counts",
       y="Detected genes") +
      ggtitle("Total number of detected genes plotted against total number of UMIs") + 
      theme(strip.background=element_rect(fill="white"), panel.background = element_rect(fill = NA),axis.line = element_line(colour = "black")) + 
      scale_fill_manual(values = c("#4dc8c9","#FB8072"))

```

##### Mitochondrial percentage vs total number of UMIs

```{r QcPlots2}
colData(sce) %>% 
    as.data.frame() %>% 
    arrange(discard) %>% 
    ggplot(aes(x = sum, y = subsets_Mito_percent)) +
      geom_point(aes(colour = discard),size=0.5) + 
      facet_wrap(vars(Sample)) +
      labs(title="Percentage of mitochondrial UMIs plotted against total number of UMIs",
       x="Total counts",
       y="Mitochondrial UMIs [%]") +
      theme(strip.background=element_rect(fill="white"), panel.background = element_rect(fill = NA),axis.line = element_line(colour = "black")) + 
      scale_fill_manual(values = c("#4dc8c9","#FB8072"))



```


#### Violin Plots Per Sample {.tabset}

##### Total counts

```{r QcPlots3}
#Plot Total count
plotColData(sce, x="Sample", y="sum",other_fields="Sample",colour_by = "discard") + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") + 
    scale_y_log10() + 
    ggtitle("Total count")+
    guides(colour=guide_legend(title="Discarded"))+
    theme(axis.text.x = element_text(angle = 45,hjust=1), axis.ticks.x=element_blank(),strip.text.x = element_blank())
```

##### Genes detected

```{r QcPlots4}
#Plot Detected Genes
plotColData(sce, x="Sample", y="detected", other_fields="Sample",colour_by ="discard")+ 
    facet_wrap(~Sample, nrow=1, scales = "free_x") + 
    scale_y_log10() + 
    ggtitle("Detected features")+
    guides(colour=guide_legend(title="Discarded"))+
    theme(axis.text.x = element_text(angle = 45,hjust=1), axis.ticks.x=element_blank(),strip.text.x = element_blank())
```

##### Mitochondrial percentage

```{r QcPlots5}
#Plot Mito percent
plotColData(sce, x="Sample", y="subsets_Mito_percent", other_fields="Sample",colour_by = data.frame(factor(sce$qc.mito | sce$qc.mito_manual,levels=c(FALSE,TRUE)))) + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") +
    ggtitle("Mito percent")+
    guides(colour=guide_legend(title="Discarded"))+
    theme(axis.text.x = element_text(angle = 45,hjust=1,), axis.ticks.x=element_blank(),strip.text.x = element_blank())
```

##### HBB percentage

```{r QcPlotshbb}
#Plot Mito percent
plotColData(sce, x="Sample", y="subsets_Hbb_percent", other_fields="Sample",colour_by = data.frame(factor(sce$qc.hbb_manual,levels=c(FALSE,TRUE)))) + 
    facet_wrap(~Sample, nrow=1, scales = "free_x") +
    ggtitle("HBB percent")+
    guides(colour=guide_legend(title="Discarded"))+
    theme(axis.text.x = element_text(angle = 45,hjust=1,), axis.ticks.x=element_blank(),strip.text.x = element_blank())
```


#### Cells to be Removed Histogramm {.tabset}

##### Absolute comparison

```{r QcPlots6}
#Cells marked to be dropped per samples
# Absolute comparison / by sample
as.data.frame(colData(sce)) %>%
  group_by(Sample, discard) %>%
  summarise(Freq=n()) %>% 
  ggplot(aes(x=Sample, y=Freq, fill=discard, label=Freq)) +
    geom_bar(stat="identity", position="stack") +
    labs(title="Cells to be dropped",
       subtitle="Labels represent absolute number of cells",
       x="",
       y="Number of cells") + 
    geom_text(size=3, position = position_stack(vjust=0.5))+
    theme(axis.text.x = element_text(angle = 45,hjust=1), axis.line = element_line(colour = "black"), panel.background = element_rect(fill = NA)) + 
    scale_fill_manual(values = c("#4dc8c9","#FB8072"))

```

##### Relative comparison

```{r QcPlots7}
#Cells marked to be dropped per samples
# Relative comparison / by sample
as.data.frame(colData(sce)) %>%
  group_by(Sample, discard) %>%
  summarise(Freq=n()) %>% 
  ggplot(aes(x=Sample, y=Freq, fill=discard, label=Freq)) +
    geom_bar(stat="identity", position="fill") +
    labs(title="Cells to be dropped",
       subtitle="Labels represent absolute number of cells",
       x="",
       y="Number of cells") + 
    geom_text(size=3, position = position_fill(vjust=0.5))+
    theme(axis.text.x = element_text(angle = 45,hjust=1), axis.line = element_line(colour = "black"), panel.background = element_rect(fill = NA))+ 
    scale_fill_manual(values = c("#4dc8c9","#FB8072"))
 

```

### Apply filtering

```{r}


# Create the filtered sce element
sce.filtered <- sce[, !colData(sce)$discard]

cat(
    "NR of Cells Before Filtering ", dim(sce)[2],
    "\nNR of Cells After Filtering ", dim(sce.filtered)[2],
    "\nNR of Cells Filtered out ", dim(sce)[2] - dim(sce.filtered)[2],
    "\nCells Filtered out: [%]", (dim(sce)[2] - dim(sce.filtered)[2])/dim(sce)[2]*100
    )
```

#### Save cell filtered Data
```{r SaveDataFiltered}
saveRDS(sce.filtered, file =paste0(path,'/output/01_sce_QualityControl_cellfiltered.rds'))
```


## Filter Genes

Additionally, perform some filtering by prevalence. If a gene is only expressed in a handful of cells, it is not particularly meaningful as it still brings down the averages for all other cells it is not expressed in. For this dataset we choose to keep only genes which are expressed in 10 or more cells. This should be performed after filtering out for low quality cells.

```{r GeneFiltering}

#Filter out genes 
dim_before_filtering <- dim(sce.filtered)

#Get only the detected Genes
detected_genes <- rowSums(counts(sce.filtered)> 0)

#Remove Genes not expressed in at least 10 Cells 
sce.filtered <- sce.filtered[detected_genes > 10,]


dim_after_filtering <- dim(sce.filtered)

cat(
    "NR of Genes Before Filtering ", dim_before_filtering[1],
    "\nNR of Genes After Filtering ", dim_after_filtering[1],
    "\nNR of Genes Filtered out ", dim_before_filtering[1] - dim_after_filtering[1],
    "\nGenes Filtered out: [%]", (dim_before_filtering[1] - dim_after_filtering[1])/dim_before_filtering[1]*100
    )

```


## Plots after Filtering

### Histogramm with number of cells {.tabset}

Show the number of cells detected in each sample or joint location after filtering

#### Per Sample
```{r PlotCellsPerSampleAfterFiltering1}
#Histogramm with number of cells per sample after filtering
ggplot(colData(sce.filtered), aes(x=Sample))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per sample") + 
  theme_classic()+
  stat_count(geom = "text", colour = "white", size = 3.5,aes(label = ..count..),position=position_stack(vjust=0.65))+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())+
  scale_y_continuous(expand = c(0,0))

t(data.frame(as.list(table(colData(sce.filtered)$Sample))))
```

#### Per Joint Location

```{r PlotCellsPerJointAfterFiltering2}
#Histogramm with number of cells per Joint after filtering
ggplot(colData(sce.filtered), aes(x=Joint.Location))+geom_bar()+ coord_flip()+ ggtitle("Number of cells per Joint") + 
  theme_classic()+
  stat_count(geom = "text", colour = "white", size = 3.5,aes(label = ..count..),position=position_stack(vjust=0.8))+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())+
  scale_y_continuous(expand = c(0,0))

t(data.frame(as.list(table(colData(sce.filtered)$Joint.Location))))
```


### Plot top 25 genes in the dataset

The most strongly and commonly expressed genes expected among all cells  are ribosomal and mitochondrial.

```{r PlotTop25GenesAfterFiltering}
#Check top 20 expressed genes after filtering

rel_expression <- t( t(counts(sce.filtered)) / colSums(counts(sce.filtered))) * 100
rownames(rel_expression) <- rowData(sce.filtered)$Symbol
most_expressed <- sort(rowSums( rel_expression ),T)[20:1]
plot_data <- as.matrix(t(rel_expression[names(most_expressed),]))

par(cex.lab=0.75)
boxplot(plot_data, cex=0.1, las=1, xlab="% total count per cell", horizontal=TRUE, main="Distribution of counts for the top 20 genes before filtering")
rm(plot_data,rel_expression)
gc()
```


## Normalization

The preprocessing step of normalization aims to adjust the raw counts in the dataset for variable sampling effects by scaling the observable variance to a specified range. Several normalization techniques are used in practice varying in complexity.

### Normalization by Library size

Library size normalization is the simplest strategy for performing scaling normalization. The library size is defined as the total sum of counts across all genes for each cell, the expected value of which is assumed to scale with any cell-specific biases. The “library size factor” for each cell is then directly proportional to its library size where the proportionality constant is defined such that the mean size factor across all cells is equal to 1. 

```{r LibrarySizeNorm}
# Library size normalization
sce.lib <- computeLibraryFactors(sce.filtered)

# Plot library size factors
ggplot(data.frame("log10libSf"=log10(sizeFactors(sce.lib))), aes(x=log10libSf)) +
  xlab("Log10 Library size factor") +
  geom_histogram(bins=50)+
  ggtitle("Distribution of Library size factors")+
  theme_bw()+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())

```


### Normalization by Deconvolution

Deconvolution aims to normalize expression values based on summed values from pools of cells which reduces composition biases that are present when any unbalanced differential expression exists between samples. Pooling counts from many cells to increase the size of the counts for accurate size factor estimation. Pool-based size factors are then “deconvolved” into cell-based factors for normalization of each cell’s expression profile. 

```{r DeconvolutionNorm}
# Normalization by deconvolution
clust.filtered <- quickCluster(sce.filtered, BPPARAM =bpp)

sce.deconv <- computeSumFactors(sce.filtered,clusters=clust.filtered, min.mean = 0.1, BPPARAM =bpp)

ggplot(data.frame("log10libSf"=log10(sizeFactors(sce.deconv))), aes(x=log10libSf)) +
  xlab("Log10 Library size factor") +
  geom_histogram(bins=50)+
  ggtitle("Distribution of Deconvolution size factors")+
  theme_bw()+
  theme(panel.grid.major.y = element_blank(),panel.grid.minor.y = element_blank())

```

```{r PrintSizeFactors}
print("Library size factors")
summary(sizeFactors(sce.lib))
print("Deconvolution size factors")
summary(sizeFactors(sce.deconv))
```

#### Plot Deconvolution against Dibrary Size Factors {.tabset}

Deconvolution size factor for each cell in the dataset, compared to the equivalent size factor derived from the library size. The red line corresponds to identity between the two size factors. Check that the estimated library sizes are not too far from the library size factors, estimated from the total number of counts.

##### Color by Individual Cluster

```{r PlotSizeFactors1}
#Color by individual cluster

 data.frame(LibrarySizeFactors = unname(sizeFactors(sce.lib)), DeconvolutionSizeFactors = sizeFactors(sce.deconv),Cluster = as.integer(clust.filtered)) %>%
     ggplot(aes(x=LibrarySizeFactors, y=DeconvolutionSizeFactors)) +
     geom_point(aes(col=factor(Cluster))) +
     geom_abline(slope = 1, intercept = 0) + theme_classic() + theme(legend.key.size = unit(0.5, 'cm'))

```

##### Color by Sample

```{r PlotSizeFactors2}
#Color by sample
data.frame(LibrarySizeFactors = unname(sizeFactors(sce.lib)), DeconvolutionSizeFactors = sizeFactors(sce.deconv),Sample = sce.filtered$Sample) %>%
     ggplot(aes(x=LibrarySizeFactors, y=DeconvolutionSizeFactors)) +
     geom_point(aes(col=Sample)) +
     geom_abline(slope = 1, intercept = 0) + theme_classic() + theme(legend.key.size = unit(0.5, 'cm'))
```


### Apply Normalization 

Apply the chosen normalization method

```{r ApplyNorm}
# Apply Normalisation
sce.filtered <- logNormCounts(sce.deconv)
summary(sizeFactors(sce.filtered))
assayNames(sce.filtered)

rm(sce.lib, sce.deconv)
gc()
```


## Variable-Level Metrics

Variable-level metrics are computed by the getVarianceExplained() function. This calculates the percentage of variance of each gene’s expression that is explained by each variable in the colData of the SingleCellExperiment object. We can then use this to determine which experimental factors are contributing most to the variance in expression. This is useful for diagnosing batch effects or to quickly verify that a treatment has an effect.

```{r VariableMetrics}
vars <- getVarianceExplained(sce.filtered,assay.type="logcounts",
    variables=c("Sample", "Joint.Location", "Pathotype","Seropositivity","GCTreatment","Protocol","Sex","Age"))
data.frame(head(vars))

plotExplanatoryVariables(vars)
```


## Save Dataset

```{r Checkdim}
dim(sce.filtered)
```

```{r SaveData}
saveRDS(sce.filtered, file =paste0(path,'/output/01_sce_QualityControl.rds'))
```
