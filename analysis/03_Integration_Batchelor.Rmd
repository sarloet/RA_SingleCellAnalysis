---
title: "Batch correction and data set integration"
subtitle: "03_Integration_Batchelor"
author: "SarahL."
date: "`r format(Sys.time(), '%b %e %Y %H:%M:%S')`"
output: 
  html_document:
    toc: true
    number_sections: true   
    toc_float: true
    code_folding: hide
    df_print: paged
editor_options:
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Batch correction and data set integration

## Setup

### Load Packages

```{r LoadPackages, warning=FALSE}
#Load Packages

suppressPackageStartupMessages({
library(BiocParallel)
library(ggplot2)
library(dplyr)
library(scater)
library(scran)
library(batchelor)
library(reticulate)
library(bluster)
})

```

### Set Parameter

```{r Setup}
set.seed(100)
bpp <- BiocParallel::MulticoreParam(parallel::detectCores()-1)
path <- here::here()
```


## Load Data

```{r LoadDataset}
## RA DATASET
sce.filtered <- readRDS(file = paste0(path,'/output/02_sce_DimensionalityReduction.rds'))
```


### Explore Dataset

```{r ShowDim}
#Dimensions of count matrix
dim(sce)
```

## Pre-Batch Correction Plots {.tabset}
### PCA
```{r}
#Plot UMAP before data integration
plotReducedDim(sce, dimred="PCA", colour_by="Sample")
```
### UMAP
```{r}
#Plot UMAP before data integration
plotReducedDim(sce, dimred="UMAP", colour_by="Sample")
```

## Batch Removal with Mutual Nearest Neighbour
The Mutual Nearest Neighbours algorithm works by determining if pairs of cells from two different batches are within the top K closest neighbours of each other.

```{r}
#Initialize sce element with batch removal
sce.BatchR <- sce 
```


### Run Batchelor 

```{r}
#Perform scaling normalization within each batch
sce.Batchelor <-batchelor::multiBatchNorm(sce, batch=sce$Sample, subset.row = rownames(sce)[rowData(sce)[["is_hvg"]]], normalize.all=TRUE, BPPARAM = bpp)
summary(sizeFactors(sce.BatchR))

```

Batches are merged in a pairwise manner (first two batches are merged to create a new cohort, then the next batch is merged with this new cohort, and so on until all batches have been integrated). Batch correction will work more effectively between batches with large number of cells and between batches that have many cells of the same cell type. As a result it is often beneficial to specify the order in which batches should be combined.

```{r}
#Set manual merge_order
merge_order <- list(
          list("SynBio028_1000","SynBio050", "SynBio074","SynBio077a", "SynBio077b"), #seronegative
          list("SynBio076", "SynBio081", "SynBio083","SynBio084","SynBio087","SynBio093", "SynBio096","SynBio098a", "SynBio098b", "SynBio127", "SynBio130", "SynBio049"))#seropositive


```


```{r, warning=FALSE}
#Perform fastMNN
bpstart(bpp)
sce.Batchelor <- batchelor::fastMNN(sce.Batchelor, batch=sce.Batchelor$Sample, prop.k=0.05,  subset.row = rownames(sce.Batchelor)[rowData(sce.Batchelor)[["is_hvg"]]], correct.all=TRUE,merge.order = merge_order,BPPARAM = bpp)#merge.order = merge_order,
bpstop(bpp)


#Save to BatchR sce object
assay(sce.BatchR, "reconstructed") <- assay(sce.Batchelor, "reconstructed")
reducedDim(sce.BatchR, 'MNN') <- reducedDim(sce.Batchelor, 'corrected')

```



### QC Plots Batchelor

We use the percentage of variance lost as a diagnostic measure. Large proportions of lost variance (>10%) suggest that correction is removing genuine biological heterogeneity.
```{r}
#Percentage Variance lost
metadata(sce.Batchelor)$merge.info$lost.var

```

## PCA Plots after Integration {.tabset}
### Colored by Sample
```{r}
#Plot PCA after data integration
plotReducedDim(sce.BatchR, dimred="MNN", colour_by="Sample") + ggtitle("PCA after data integration with fastMNN")
```
### Colored by Joint
```{r}
#Plot PCA after data integration
plotReducedDim(sce.BatchR, dimred="MNN", colour_by="JointLocation") + ggtitle("PCA after data integration with fastMNN")
```
### Facet by Sample
```{r}
#Plot PCA after data integration per sample
plotReducedDim(sce.BatchR, dimred="MNN", colour_by="Sample") + ggtitle("PCA after data integration with fastMNN")+ facet_wrap(~sce.BatchR$Sample)
```
### Facet by Joint
```{r}
#Plot PCA before data integration per joint
plotReducedDim(sce.BatchR, dimred="MNN", colour_by="JointLocation") + ggtitle("PCA after data integration with fastMNN")+ facet_wrap(~sce.BatchR$JointLocation)
```


## UMAP Plots after Integration {.tabset}

```{r}
#Run UMAP
sce.BatchR <- runUMAP(sce.BatchR ,name = "MNN_UMAP", dimred = "MNN")

```

### Colored by Sample
```{r}
#Plot UMAP after data integration
plotReducedDim(sce.BatchR, dimred="MNN_UMAP", colour_by="Sample") + ggtitle("UMAP after data integration with fastMNN")
```
### Colored by Joint
```{r}
#Plot UMAP after data integration
plotReducedDim(sce.BatchR, dimred="MNN_UMAP", colour_by="JointLocation") + ggtitle("UMAP after data integration with fastMNN")#+ facet_wrap(~sce.filtered$Sample)
```
### Facet by Sample
```{r}
#Plot UMAP before data integration per sample
plotReducedDim(sce.BatchR, dimred="MNN_UMAP", colour_by="Sample") + ggtitle("UMAP after data integration with fastMNN")+ facet_wrap(~sce.BatchR$Sample)
```
### Facet by Joint
```{r}
#Plot UMAP before data integration per joint
plotReducedDim(sce.BatchR, dimred="MNN_UMAP", colour_by="JointLocation") + ggtitle("UMAP after data integration with fastMNN")+ facet_wrap(~sce.BatchR$JointLocation)
```

## Save the dataset

```{r SaveData}
saveRDS(sce.filtered, file =paste0(path,'/output/03_sce_Integrated_Batchelor.rds'))
```
